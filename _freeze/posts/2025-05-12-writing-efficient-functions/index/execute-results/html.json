{
  "hash": "65b6af5790f4f1b4a9d57a4582fd2cfa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Writing Efficient Functions\"\nauthor: \"Harshini Karthikeyan\"\ndate: '05-12-2025'\nformat:\n  html:\n    backgroundcolor: whitesmoke\n    monobackgroundcolor: lightsteelblue\n    fontcolor: black\n    number_sections: yes\n#mainfont: default\neditor: visual\ntoc: true\ntoc_float: true\nembed-resources: true\nimage: dashboard_preview.JPG\n---\n\n\n\n# Lab 6 - Spicier\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dplyr)\ndiamonds<- ggplot2::diamonds\nflights<- nycflights13::flights\n```\n:::\n\n\n\n## **Exercise 1: Helper Functions** \n\nWrite a function that removes outliers in a dataset. The user should be able to supply the dataset, the variables to remove outliers from, and a threshold on the number of SDs away from the mean used to define outliers.\n\n*Hint 1: You will need to calculate a z-score to filter the values!* \n\n*Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_outliers<- function(data, ... , sd_threshold = 3){\n  \n  variables <- as.character(substitute(list(...)))[-1]\n  \n  keep <- rep(TRUE, nrow(data))\n  # dataframe of values to keep\n  \n  for(each in variables){\n    if (!is.numeric(data[[each]])) {\n      warning(paste(\"Variable\", each\n                 , \"is not numeric! Only numeric variables are supported! We cannot drop outliers from this column\"))\n      next\n      # returns error for non-numeric variables\n    }\n    \n    mu <- mean(data[[each]])\n    sd <- sd(data[[each]])\n    z_scores <- (data[[each]] - mu) / sd\n    # find the zscore of each instance of each variable\n    \n    keep <- keep & abs(z_scores) < sd_threshold\n    # filters out values where the zscore is greater than the specified threshold\n      }\n  return (data[keep, ])\n\n  \n}\n\n# [[]] vs [] https://stackoverflow.com/questions/1169456/the-difference-between-bracket-and-double-bracket-for-accessing-the-el\n```\n:::\n\n\n\nThis function is not the most efficient as it does use a for loop.\n\n#### Testing Your Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\n\nremove_outliers(diamonds, \n                price, \n                x, \n                y, \n                z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, \n                price, \n                color)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in remove_outliers(diamonds, price, color): Variable color is not\nnumeric! Only numeric variables are supported! We cannot drop outliers from\nthis column\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,734 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,724 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, \n                price,\n                x, \n                y, \n                z, \n                sd_threshold = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n\n## **Exercise 2: Helper Functions**\n\nWrite a function that imputes missing values for numeric variables in a dataset. The user should be able to supply the dataset, the variables to impute values for, and a function to use when imputing. *Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.* *Hint 2: The `replace_na()` function is helpful here!*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimpute_missing <- function( data, ..., func = sum){\n  # capture variable names\n  variables <- as.character(substitute(list(...)))[-1]\n  \n   #issues a warning for non-numeric variables and retains them in the dataset without imputing\n  numeric_variables <- variables[sapply(variables, function(x) is.numeric(data[[x]]))]\n  \n  non_numeric_vars <- setdiff(variables, numeric_variables)\n  \n  if(length(non_numeric_vars) > 0) {\n    warning(paste(\"The following variables are non-numeric and will not be imputed:\", paste(non_numeric_vars, collapse = \", \")))\n  }\n  \n  data |>\n    mutate(across(\n      .cols = all_of(numeric_variables),\n      .fns = ~ replace_na(.x, func(.x, na.rm = TRUE))\n    ))\n}\n```\n:::\n\n\n\nThis function is more efficient than the last one as it uses `sapply()` and the usage of dplyr makes this function more efficient than the last one.\n\n#### Testing Your Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(flights, \n               arr_delay, \n               dep_delay) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(flights, \n               arr_delay, \n               carrier)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in impute_missing(flights, arr_delay, carrier): The following variables\nare non-numeric and will not be imputed: carrier\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(flights, \n               arr_delay, \n               dep_delay, \n               func = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n## Exercise 3: Primary Function\n\nWrite a `fit_model()` function that fits a specified linear regression model for a specified dataset. The function should:\n\n-   allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n\n-   allow the user to specify if missing observations should be imputed (`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()` or `impute_missing()` functions to modify the data **before** the regression model is fit.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(data, mod_formula, remove_outliers = FALSE, impute_missing = FALSE, ...) {\n  \n  #run helper functions if indicated\n  if (remove_outliers) {\n    data <- remove_outliers(data, ...)\n  }\n  \n  if (impute_missing) {\n    data <- impute_missing(data, ...)\n  }\n  \n  #fit the linear regression model\n  model <- lm(mod_formula, data = data)\n  \n  # Return the fitted model\n  return(model)\n}\n```\n:::\n\n\n\n#### Test Your Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  price, \n  carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n```\n\n\n:::\n:::\n\n\n\n### **Iteration**\n\nIn the `diamonds` dataset, we want to understand the relationship between `price` and size (`carat`). We want to explore variation along two choices:\n\n1.  The variables included in the model. We’ll explore 3 sets of variables:\n\n    -   No further variables (just `price` and `carat`)\n\n    -   Adjusting for `cut`\n\n    -   Adjusting for `cut` and `clarity`\n\n    -   Adjusting for `cut`, `clarity`, and `color`\n\n2.  Whether or not to impute missing values\n\n3.  Whether or not to remove outliers in the `carat` variable (we’ll define outliers as cases whose `carat` is over 3 SDs away from the mean).\n\n## Exercise 4: Parameters\n\nFirst, we need to define the set of parameters we want to iterate the `fit_model()` function over. The `tidyr` package has a useful function called `crossing()` that is useful for generating argument combinations. For each argument, we specify all possible values for that argument and `crossing()` generates all combinations. *Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- crossing(\n    impute = c(TRUE, FALSE),\n    remove_outliers = c(TRUE, FALSE), \n    mod = c(y ~ x1, \n            y ~ x1 + x2)\n)\ndf_arg_combos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  impute remove_outliers mod      \n  <lgl>  <lgl>           <list>   \n1 FALSE  FALSE           <formula>\n2 FALSE  FALSE           <formula>\n3 FALSE  TRUE            <formula>\n4 FALSE  TRUE            <formula>\n5 TRUE   FALSE           <formula>\n6 TRUE   FALSE           <formula>\n7 TRUE   TRUE            <formula>\n8 TRUE   TRUE            <formula>\n```\n\n\n:::\n:::\n\n\n\nUse `crossing()` to create the data frame of argument combinations for our analyses.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam_sets <- crossing(\n  impute = c(TRUE, FALSE),                           \n  remove_outliers = c(TRUE, FALSE),                   \n  mod = c(                                        \n    price ~ carat,   # No adjustment    \n    \n    price ~ carat + cut,                             \n    price ~ carat + cut + clarity,     \n    \n    # Adjusting for cut, clarity, and color\n    price ~ carat + cut + clarity + color            \n  )\n)\nparam_sets\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   impute remove_outliers mod      \n   <lgl>  <lgl>           <list>   \n 1 FALSE  FALSE           <formula>\n 2 FALSE  FALSE           <formula>\n 3 FALSE  FALSE           <formula>\n 4 FALSE  FALSE           <formula>\n 5 FALSE  TRUE            <formula>\n 6 FALSE  TRUE            <formula>\n 7 FALSE  TRUE            <formula>\n 8 FALSE  TRUE            <formula>\n 9 TRUE   FALSE           <formula>\n10 TRUE   FALSE           <formula>\n11 TRUE   FALSE           <formula>\n12 TRUE   FALSE           <formula>\n13 TRUE   TRUE            <formula>\n14 TRUE   TRUE            <formula>\n15 TRUE   TRUE            <formula>\n16 TRUE   TRUE            <formula>\n```\n\n\n:::\n:::\n\n\n\n## Exercise 5: Iterating Over Parameters\n\nUse `pmap()` from `purrr` to apply the `fit_model()` function to every combination of arguments from `diamonds.`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam_sets<-param_sets |>\n  mutate(model = pmap(list(impute, remove_outliers, mod), \n                      function(impute, remove_outliers, mod) {\n                        fit_model(\n                          data = diamonds,\n                          mod_formula = mod,\n                          remove_outliers = remove_outliers,\n                          impute_missing = impute,\n                          price,\n                          carat\n                          # variable to use for outlier removal and imputation\n                          # variables cut, clarity and color are non-numeric\n                        )\n                      }))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(param_sets$model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[2]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[3]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[4]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[5]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat  \n      -2067         7411  \n\n\n[[6]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n\n\n[[7]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2897.60      8118.13       618.65      -268.13       148.57         8.10  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n    3463.17     -1505.52       609.45      -286.81       158.48        71.83  \n  clarity^7  \n     183.33  \n\n\n[[8]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3376.856     8513.377      607.668     -263.835      142.453        5.506  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3654.785    -1503.171      612.049     -225.568      124.920       47.356  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    112.889    -1714.316     -539.239     -127.282       43.649      -60.866  \n    color^6  \n    -49.333  \n\n\n[[9]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[10]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[11]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[12]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[13]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat  \n      -2067         7411  \n\n\n[[14]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n\n\n[[15]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2897.60      8118.13       618.65      -268.13       148.57         8.10  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n    3463.17     -1505.52       609.45      -286.81       158.48        71.83  \n  clarity^7  \n     183.33  \n\n\n[[16]]\n\nCall:\nlm(formula = mod_formula, data = data)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3376.856     8513.377      607.668     -263.835      142.453        5.506  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3654.785    -1503.171      612.049     -225.568      124.920       47.356  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    112.889    -1714.316     -539.239     -127.282       43.649      -60.866  \n    color^6  \n    -49.333  \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}